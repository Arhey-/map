<html>
  <head>
    <title>map</title>
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <meta name="color-scheme" content="dark light">
    <style>
      body { background-color: #222; color: #ccc; }
      .edit-mode li { padding: 0.15em 0; }
      a { color: #39c; text-decoration: none; }
      a:hover { color: #6cf; }
      ul { padding-left: 1em; }
      li::marker { color: rgba(255,255,255,0.3); }
      summary { margin-left: -1em; }
      .tool { position: sticky; bottom: 0; background-color: rgba(0, 0, 0, 0.7); }
      .wide { width: 100% }
    </style>
  </head>
  <body>
    <script type='module'>
      import { html, select, fold } from '../lib/html.js'
      import { bookmarklet } from './bookmarklet.js'

      const user = localStorage.bitbucketWorkspace;
      const auth = localStorage.bitbucketAppPwd;
      const id = localStorage.bitbucketSnippetId;
      const snippetUrl = `https://api.bitbucket.org/2.0/snippets/${user}/${id}`
      const headers = { 'Authorization': 'Basic ' + btoa(user + ':' + auth) };
      const isMobile = navigator.userAgent.includes('obile');
      const loadedFiles = new Map, changedFiles = new Set;
      const arrByUl = new Map;
      const tool = {
        get active() { return adding.name_?.value || tool.action.value }
      };
      
      if (!user || !auth || !id) {
        editCredentials();
      } else try {
        const n = new URL(location).searchParams.get('file') || 'index'
        const root = await get(n);
        document.addEventListener('click', handlePlace);
        document.body.append(sub(root.arr, n));
        makeTool();
      } catch (e) {
        editCredentials(e);
      }
      
      async function get(name) {
        const r = await fetch(`${snippetUrl}/files/${name}.json`, { headers });
        if (!r.ok) throw r.status;
        const f = await r.json();
        loadedFiles.set(name, f);
        return f;
      }

      async function put(name) {
        if (name) changedFiles.add(name)
        if (!changedFiles.size || tool.batch.checked) {
          return;
        }
        const uploadNames = [...changedFiles]
        const r = await fetch(snippetUrl, {
          method: 'PUT',
          headers,
          body: makeFilesForm(uploadNames),
        });
        if (!r.ok) throw r.status;
        uploadNames.forEach(n => changedFiles.delete(n))
        return r
      }

      function makeFilesForm(names) {
        const form = new FormData
        for (const name of names) {
          const f = makeFile(name)
          form.append('file', f, f.name); //todo same name?
        }
        return form
      }

      function makeFile(name) {
        const obj = loadedFiles.get(name)
        const json = JSON.stringify(obj, null, 1)
        return new File([json], name + '.json', { type: "text/json" })
      }

      function sub(arr, ofFile) {
        const ul = html.ul(...arr.map(build))
        if (ofFile) ul.style.setProperty('--file', ofFile)
        arrByUl.set(ul, arr)
        return ul
      }

      function build(i) {
        if (i.file) {
          const b = html.button(() => fileLoader(i.file, b), i.name);
          const a = html.a({ target: '_blank', href: '?file=' + i.file }, ' tab');
          return html.li(b, a);
        }
        const title = !i.url ? i.name : html.a({
          target: '_blank',
          href: i.url,
        }, i.name)
        if (i.fold && i.arr) {
          return html.li(fold(title, sub(i.arr)))
        }
        const li = html.li(title);
        if (i.arr) li.append(sub(i.arr));
        return li;
      }

      function fileLoader(name, button) {
        if (tool.active) return;
        button.disabled = true;
        get(name)
          .then(f => button.after(sub(f.arr, name)))
          .catch(e => {
            button.disabled = false;
            document.body.prepend(e);
          });
      }


      function makeTool(){
        const add = html.button(adding, 'add')

        const action = select([['', 'action'], 'sub', 'fold', 'rm', 'mv'])
        if (isMobile) action.onchange = () => {
          document.body.classList.toggle('edit-mode', action.value)
        }
        tool.action = action

        const batch = html.input({ type: 'checkbox', onchange: () => {
          if (batch.checked) return;
          action.value = ''
          action.onchange?.()
          put()
            .then(() => alert('ok')) //todo better ui
            .catch(e => alert('err: ' + e))
        } })
        tool.batch = batch

        document.body.append(
          html.div({ className: 'tool' }, html.div(
            add,
            action,
            html.label(batch, 'batch')
          ))
        )
      }

      function adding() {
        if (adding.name_) return;
        const name = html.input({ placeholder: 'name or .bkm', className: 'wide', onfocus: () => {
          if (!name.value) navigator.clipboard.readText().then(n => {
            if (n.startsWith('{')) {
              name.value = n
              name.onchange()
              navigator.clipboard.writeText('')
            }
          })
        } })
        name.onchange = () => {
          if (name.value == '.bkm') {
            navigator.clipboard.writeText(bookmarklet).then(() => name.value = '')
            return;
          }
          if (name.value.startsWith('{"name":"')) {
            const i = JSON.parse(name.value)
            name.value = i.name;
            url.value = i.url;
          }
        }
        const url = html.input({ placeholder: 'url', className: 'wide' })
        document.body
          .querySelector('.tool')
          .prepend(name, url)
        adding.name_ = name;
        adding.url = url;
      }

      function handlePlace(e) {
        if (!tool.active) return;
        const file = getComputedStyle(e.target).getPropertyValue('--file')
        if (!file) return;
        if (e.target.tagName == 'UL') {
          alert('tap on list item')
          return
        }
        e.preventDefault()
        e.stopPropagation()
        const action = tool.action.value
        if ('sub' == action) return syncSub(e.target, file)
        if ('fold' == action) return syncFold(e.target, file)
        if ('rm' == action || action == 'mv' && !lastDel) {
          syncRm(e.target, file); return
        }
        if ('mv' == action) return syncMv(e.target, file)

        syncAdd(e.target, file, adding.name_.value, adding.url.value);
        adding.name_.value = adding.url.value = '';
      }
    
      function syncAdd(target, file, name, url) {
        const i = { name };
        if (url) i.url = url;

        const [arr, n, li] = targets(target)
        arr.splice(n, 0, i)

        put(file)
          .then(() => li.before(build(i)))
          .catch(alert)
      }

      async function syncMv(target, file) {
        const [arr, n, li] = targets(target)
        arr.splice(n, 0, lastDel)
        try {
          await put(file)
          li.before(lastElDel)
          lastDel = null
        } catch (e){
          alert(e)
        }
      }

      let lastDel, lastElDel

      async function syncRm(target, file) {
        const [arr, n, li] = targets(target)
        if (!tool.batch.checked && !confirm(`rm ${arr[n].name} ?`)) return;
        [lastDel] = arr.splice(n, 1)
        try {
          await put(file)
          li.remove()
          lastElDel = li
        } catch (e) {
          lastDel = null;
          alert(e)
        }
      }

      function syncFold(target, file) {
        const [arr, n, li] = targets(target)
        const i = arr[n];
        if (!i.arr) return alert('this is no list')
        if (i.fold) return alert('alredy folded')
        i.fold = true
        put(file)
          .then(() => li.append(fold(li.firstChild, li.querySelector('ul'))))
      }

      async function syncSub(target, file) {
        const [arr, n, li] = targets(target)
        const p = arr[n - 1];
        if (!p) return alert('no prev')
        if (p.file) return alert('file cannot be prev, use move')
        const prevLi = li.previousElementSibling
        li.remove()
        const prevWasList = p.arr
        if (prevWasList) {
          p.arr.push(arr[n])
        } else {
          p.arr = [arr[n]]
        }
        arr.splice(n, 1)
        try {
          await put(file)
        } catch {
          arr.splice(n, 0, p.arr.pop())
          if (!prevWasList) delete p.arr
          prevLi.after(li)
        }
        if (prevWasList) {
          prevLi.querySelector('ul').append(li)
        } else {
          const ul = html.ul(li)
          prevLi.append(ul)
          arrByUl.set(ul, p.arr)
        }
      }

      function targets(el) {
        const li = el.tagName == 'LI'
          ? el
          : findParent('LI', el)
        const ul = findParent('UL', li)
        const arr = arrByUl.get(ul)
        const n = Array.from(ul.children).findIndex(i => i == li)
        return [arr, n, li]
      }

      function findParent(name, el) {
        while (el = el.parentElement) {
          if (el.tagName == name) return el 
        }
      }

      function editCredentials(error = '') {
        document.body.innerHTML = `<p>${error}</p>`;
        document.body.append(
          input('Workspace', user),
          input('SnippetId', id),
          input('AppPwd', auth),
          html.p('enter correct bitbucket creds and reload')
        );
      }

      function input(name, value = '') {
        const i = html.input({
          type: 'text',
          value,
          onchange: () => localStorage.setItem('bitbucket' + name, i.value),
        });
        return html.p(html.label(name, i));
      }
    </script>
  </body>
</html>
